// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: content.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createContent = `-- name: CreateContent :one
INSERT INTO content (
    user_id,
    category_id,
    title,
    content_description,
    comments_enabled,
    view_count_enabled,
    like_count_enabled,
    dislike_count_enabled
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING content_id, user_id, category_id, title, content_description, comments_enabled, view_count_enabled, like_count_enabled, dislike_count_enabled, status, view_count, like_count, dislike_count, comment_count, created_at, updated_at, published_at, is_deleted
`

type CreateContentParams struct {
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
}

func (q *Queries) CreateContent(ctx context.Context, arg CreateContentParams) (Content, error) {
	row := q.db.QueryRow(ctx, createContent,
		arg.UserID,
		arg.CategoryID,
		arg.Title,
		arg.ContentDescription,
		arg.CommentsEnabled,
		arg.ViewCountEnabled,
		arg.LikeCountEnabled,
		arg.DislikeCountEnabled,
	)
	var i Content
	err := row.Scan(
		&i.ContentID,
		&i.UserID,
		&i.CategoryID,
		&i.Title,
		&i.ContentDescription,
		&i.CommentsEnabled,
		&i.ViewCountEnabled,
		&i.LikeCountEnabled,
		&i.DislikeCountEnabled,
		&i.Status,
		&i.ViewCount,
		&i.LikeCount,
		&i.DislikeCount,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.IsDeleted,
	)
	return i, err
}

const deleteContentReaction = `-- name: DeleteContentReaction :one
DELETE FROM content_reaction
WHERE content_id = $1 AND user_id = $2
RETURNING content_id
`

type DeleteContentReactionParams struct {
	ContentID pgtype.UUID
	UserID    pgtype.UUID
}

func (q *Queries) DeleteContentReaction(ctx context.Context, arg DeleteContentReactionParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, deleteContentReaction, arg.ContentID, arg.UserID)
	var content_id pgtype.UUID
	err := row.Scan(&content_id)
	return content_id, err
}

const fetchContentReactions = `-- name: FetchContentReactions :many
SELECT
  cr.content_id, cr.user_id, cr.reaction,
  row_to_json(u) AS user_info
FROM content_reaction cr
JOIN "user" u ON cr.user_id = u.user_id
WHERE cr.content_id = $1
`

type FetchContentReactionsRow struct {
	ContentID pgtype.UUID
	UserID    pgtype.UUID
	Reaction  string
	UserInfo  []byte
}

func (q *Queries) FetchContentReactions(ctx context.Context, contentID pgtype.UUID) ([]FetchContentReactionsRow, error) {
	rows, err := q.db.Query(ctx, fetchContentReactions, contentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchContentReactionsRow
	for rows.Next() {
		var i FetchContentReactionsRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.Reaction,
			&i.UserInfo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContentDetails = `-- name: GetContentDetails :one
SELECT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  row_to_json(u) AS author,
  row_to_json(cat) AS category,
  (
    SELECT array_agg(t.tag_name)
    FROM content_tag ct
    JOIN tag t ON ct.tag_id = t.tag_id
    WHERE ct.content_id = c.content_id -- No ambiguity here
  ) AS tags,
  (
    SELECT json_agg(m)
    FROM (
      SELECT media_id, media_type, media_url, media_caption, media_order
      FROM media m -- Add alias for the media table
      WHERE m.content_id = c.content_id
      ORDER BY m.media_order
    ) m
  ) AS media,
  (
    SELECT count(*)
    FROM content_reaction cr
    WHERE cr.content_id = c.content_id -- This is where qualification is needed
  ) AS reaction_count,
  (
    SELECT count(*)
    FROM comment cm
    WHERE cm.content_id = c.content_id
      AND cm.is_deleted = false
  ) AS comment_count_sync
FROM content c
JOIN "user" u ON c.user_id = u.user_id
JOIN category cat ON c.category_id = cat.category_id
WHERE c.content_id = $1
`

type GetContentDetailsRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Author              []byte
	Category            []byte
	Tags                interface{}
	Media               []byte
	ReactionCount       int64
	CommentCountSync    int64
}

func (q *Queries) GetContentDetails(ctx context.Context, contentID pgtype.UUID) (GetContentDetailsRow, error) {
	row := q.db.QueryRow(ctx, getContentDetails, contentID)
	var i GetContentDetailsRow
	err := row.Scan(
		&i.ContentID,
		&i.UserID,
		&i.CategoryID,
		&i.Title,
		&i.ContentDescription,
		&i.CommentsEnabled,
		&i.ViewCountEnabled,
		&i.LikeCountEnabled,
		&i.DislikeCountEnabled,
		&i.Status,
		&i.ViewCount,
		&i.LikeCount,
		&i.DislikeCount,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.IsDeleted,
		&i.Author,
		&i.Category,
		&i.Tags,
		&i.Media,
		&i.ReactionCount,
		&i.CommentCountSync,
	)
	return i, err
}

const getContentOverview = `-- name: GetContentOverview :one
SELECT 
  COUNT(*) FILTER (WHERE status = 'draft' AND is_deleted = false) AS draft_count,
  COUNT(*) FILTER (WHERE status = 'published' AND is_deleted = false) AS published_count,
  COUNT(*) FILTER (WHERE is_deleted = true) AS deleted_count
FROM content
`

type GetContentOverviewRow struct {
	DraftCount     int64
	PublishedCount int64
	DeletedCount   int64
}

func (q *Queries) GetContentOverview(ctx context.Context) (GetContentOverviewRow, error) {
	row := q.db.QueryRow(ctx, getContentOverview)
	var i GetContentOverviewRow
	err := row.Scan(&i.DraftCount, &i.PublishedCount, &i.DeletedCount)
	return i, err
}

const incrementViewCount = `-- name: IncrementViewCount :one
UPDATE content
SET
  view_count = view_count + 1
WHERE content_id = $1
RETURNING view_count
`

func (q *Queries) IncrementViewCount(ctx context.Context, contentID pgtype.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, incrementViewCount, contentID)
	var view_count int32
	err := row.Scan(&view_count)
	return view_count, err
}

const insertOrUpdateContentReaction = `-- name: InsertOrUpdateContentReaction :one
INSERT INTO content_reaction (content_id, user_id, reaction)
VALUES ($1, $2, $3)
ON CONFLICT (content_id, user_id)
DO UPDATE SET reaction = EXCLUDED.reaction
RETURNING content_id
`

type InsertOrUpdateContentReactionParams struct {
	ContentID pgtype.UUID
	UserID    pgtype.UUID
	Reaction  string
}

func (q *Queries) InsertOrUpdateContentReaction(ctx context.Context, arg InsertOrUpdateContentReactionParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertOrUpdateContentReaction, arg.ContentID, arg.UserID, arg.Reaction)
	var content_id pgtype.UUID
	err := row.Scan(&content_id)
	return content_id, err
}

const listContentByCategory = `-- name: ListContentByCategory :many
SELECT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  row_to_json(u) AS author
FROM content c
JOIN "user" u ON c.user_id = u.user_id
WHERE c.category_id = $1
  AND c.status = 'published'
  AND c.is_deleted = false
ORDER BY c.published_at DESC
LIMIT $2 OFFSET $3
`

type ListContentByCategoryParams struct {
	CategoryID pgtype.UUID
	Limit      int32
	Offset     int32
}

type ListContentByCategoryRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Author              []byte
}

func (q *Queries) ListContentByCategory(ctx context.Context, arg ListContentByCategoryParams) ([]ListContentByCategoryRow, error) {
	rows, err := q.db.Query(ctx, listContentByCategory, arg.CategoryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContentByCategoryRow
	for rows.Next() {
		var i ListContentByCategoryRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Author,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentByTag = `-- name: ListContentByTag :many
SELECT DISTINCT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  row_to_json(u) AS author,
  row_to_json(cat) AS category
FROM content c
JOIN "user" u ON c.user_id = u.user_id
JOIN category cat ON c.category_id = cat.category_id
JOIN content_tag ct ON c.content_id = ct.content_id
JOIN tag t ON ct.tag_id = t.tag_id
WHERE t.tag_name = $1
  AND c.status = 'published'
  AND c.is_deleted = false
ORDER BY c.published_at DESC
LIMIT $2 OFFSET $3
`

type ListContentByTagParams struct {
	TagName string
	Limit   int32
	Offset  int32
}

type ListContentByTagRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Author              []byte
	Category            []byte
}

func (q *Queries) ListContentByTag(ctx context.Context, arg ListContentByTagParams) ([]ListContentByTagRow, error) {
	rows, err := q.db.Query(ctx, listContentByTag, arg.TagName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContentByTagRow
	for rows.Next() {
		var i ListContentByTagRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Author,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentForModeration = `-- name: ListContentForModeration :many
SELECT c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted, row_to_json(u) AS author
FROM content c
JOIN "user" u ON c.user_id = u.user_id
WHERE u.banned = true
ORDER BY c.created_at DESC
LIMIT $1 OFFSET $2
`

type ListContentForModerationParams struct {
	Limit  int32
	Offset int32
}

type ListContentForModerationRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Author              []byte
}

func (q *Queries) ListContentForModeration(ctx context.Context, arg ListContentForModerationParams) ([]ListContentForModerationRow, error) {
	rows, err := q.db.Query(ctx, listContentForModeration, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContentForModerationRow
	for rows.Next() {
		var i ListContentForModerationRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Author,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedContent = `-- name: ListPublishedContent :many
SELECT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  row_to_json(u) AS author,
  row_to_json(cat) AS category
FROM content c
JOIN "user" u ON c.user_id = u.user_id
JOIN category cat ON c.category_id = cat.category_id
WHERE c.status = 'published'
  AND c.is_deleted = false
ORDER BY c.published_at DESC
LIMIT $1 OFFSET $2
`

type ListPublishedContentParams struct {
	Limit  int32
	Offset int32
}

type ListPublishedContentRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Author              []byte
	Category            []byte
}

func (q *Queries) ListPublishedContent(ctx context.Context, arg ListPublishedContentParams) ([]ListPublishedContentRow, error) {
	rows, err := q.db.Query(ctx, listPublishedContent, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPublishedContentRow
	for rows.Next() {
		var i ListPublishedContentRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Author,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRelatedContentByCategory = `-- name: ListRelatedContentByCategory :many
SELECT c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted, row_to_json(u) AS author
FROM content c
JOIN "user" u ON c.user_id = u.user_id
WHERE c.category_id = $1
  AND c.content_id <> $2
  AND c.status = 'published'
  AND c.is_deleted = false
ORDER BY c.published_at DESC
LIMIT $3
`

type ListRelatedContentByCategoryParams struct {
	CategoryID pgtype.UUID
	ContentID  pgtype.UUID
	Limit      int32
}

type ListRelatedContentByCategoryRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Author              []byte
}

func (q *Queries) ListRelatedContentByCategory(ctx context.Context, arg ListRelatedContentByCategoryParams) ([]ListRelatedContentByCategoryRow, error) {
	rows, err := q.db.Query(ctx, listRelatedContentByCategory, arg.CategoryID, arg.ContentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRelatedContentByCategoryRow
	for rows.Next() {
		var i ListRelatedContentByCategoryRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Author,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRelatedContentByTag = `-- name: ListRelatedContentByTag :many
SELECT DISTINCT c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted, row_to_json(u) AS author
FROM content c
JOIN content_tag ct ON c.content_id = ct.content_id
JOIN tag t ON ct.tag_id = t.tag_id
JOIN "user" u ON c.user_id = u.user_id
WHERE t.tag_id = $1
  AND c.content_id <> $2
  AND c.status = 'published'
  AND c.is_deleted = false
ORDER BY c.published_at DESC
LIMIT $3
`

type ListRelatedContentByTagParams struct {
	TagID     pgtype.UUID
	ContentID pgtype.UUID
	Limit     int32
}

type ListRelatedContentByTagRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Author              []byte
}

func (q *Queries) ListRelatedContentByTag(ctx context.Context, arg ListRelatedContentByTagParams) ([]ListRelatedContentByTagRow, error) {
	rows, err := q.db.Query(ctx, listRelatedContentByTag, arg.TagID, arg.ContentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRelatedContentByTagRow
	for rows.Next() {
		var i ListRelatedContentByTagRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Author,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTrendingContent = `-- name: ListTrendingContent :many
SELECT 
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  (c.view_count + c.like_count + c.comment_count) AS total_interactions
FROM content c
WHERE c.status = 'published'
  AND c.is_deleted = false
  AND c.published_at >= $1
ORDER BY total_interactions DESC
LIMIT $2
`

type ListTrendingContentParams struct {
	PublishedAt pgtype.Timestamptz
	Limit       int32
}

type ListTrendingContentRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	TotalInteractions   int32
}

func (q *Queries) ListTrendingContent(ctx context.Context, arg ListTrendingContentParams) ([]ListTrendingContentRow, error) {
	rows, err := q.db.Query(ctx, listTrendingContent, arg.PublishedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTrendingContentRow
	for rows.Next() {
		var i ListTrendingContentRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.TotalInteractions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publishContent = `-- name: PublishContent :one
UPDATE content
SET
    status = 'published',
    published_at = now(),
    updated_at = now()
WHERE content_id = $1
RETURNING content_id, user_id, category_id, title, content_description, comments_enabled, view_count_enabled, like_count_enabled, dislike_count_enabled, status, view_count, like_count, dislike_count, comment_count, created_at, updated_at, published_at, is_deleted
`

func (q *Queries) PublishContent(ctx context.Context, contentID pgtype.UUID) (Content, error) {
	row := q.db.QueryRow(ctx, publishContent, contentID)
	var i Content
	err := row.Scan(
		&i.ContentID,
		&i.UserID,
		&i.CategoryID,
		&i.Title,
		&i.ContentDescription,
		&i.CommentsEnabled,
		&i.ViewCountEnabled,
		&i.LikeCountEnabled,
		&i.DislikeCountEnabled,
		&i.Status,
		&i.ViewCount,
		&i.LikeCount,
		&i.DislikeCount,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.IsDeleted,
	)
	return i, err
}

const searchContent = `-- name: SearchContent :many
SELECT DISTINCT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  row_to_json(u) AS author,
  row_to_json(cat) AS category
FROM content c
JOIN "user" u ON c.user_id = u.user_id
JOIN category cat ON c.category_id = cat.category_id
LEFT JOIN content_tag ct ON c.content_id = ct.content_id
LEFT JOIN tag t ON ct.tag_id = t.tag_id
WHERE c.status = 'published'
  AND c.is_deleted = false
  AND (
    c.title ILIKE '%' || $1 || '%'
    OR c.content_description ILIKE '%' || $1 || '%'
    OR t.tag_name ILIKE '%' || $1 || '%'
  )
ORDER BY c.published_at DESC
LIMIT $2 OFFSET $3
`

type SearchContentParams struct {
	Column1 pgtype.Text
	Limit   int32
	Offset  int32
}

type SearchContentRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Author              []byte
	Category            []byte
}

func (q *Queries) SearchContent(ctx context.Context, arg SearchContentParams) ([]SearchContentRow, error) {
	rows, err := q.db.Query(ctx, searchContent, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchContentRow
	for rows.Next() {
		var i SearchContentRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Author,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteContent = `-- name: SoftDeleteContent :one
UPDATE content
SET
    is_deleted = true,
    updated_at = now()
WHERE content_id = $1
RETURNING content_id, user_id, category_id, title, content_description, comments_enabled, view_count_enabled, like_count_enabled, dislike_count_enabled, status, view_count, like_count, dislike_count, comment_count, created_at, updated_at, published_at, is_deleted
`

func (q *Queries) SoftDeleteContent(ctx context.Context, contentID pgtype.UUID) (Content, error) {
	row := q.db.QueryRow(ctx, softDeleteContent, contentID)
	var i Content
	err := row.Scan(
		&i.ContentID,
		&i.UserID,
		&i.CategoryID,
		&i.Title,
		&i.ContentDescription,
		&i.CommentsEnabled,
		&i.ViewCountEnabled,
		&i.LikeCountEnabled,
		&i.DislikeCountEnabled,
		&i.Status,
		&i.ViewCount,
		&i.LikeCount,
		&i.DislikeCount,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.IsDeleted,
	)
	return i, err
}

const updateContent = `-- name: UpdateContent :one
UPDATE content
SET
    title = COALESCE($2, title),
    content_description = COALESCE($3, content_description),
    category_id = COALESCE($4, category_id),
    comments_enabled = COALESCE($5, comments_enabled),
    view_count_enabled = COALESCE($6, view_count_enabled),
    like_count_enabled = COALESCE($7, like_count_enabled),
    dislike_count_enabled = COALESCE($8, dislike_count_enabled),
    updated_at = now()
WHERE content_id = $1
RETURNING content_id, user_id, category_id, title, content_description, comments_enabled, view_count_enabled, like_count_enabled, dislike_count_enabled, status, view_count, like_count, dislike_count, comment_count, created_at, updated_at, published_at, is_deleted
`

type UpdateContentParams struct {
	ContentID           pgtype.UUID
	Title               string
	ContentDescription  string
	CategoryID          pgtype.UUID
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
}

func (q *Queries) UpdateContent(ctx context.Context, arg UpdateContentParams) (Content, error) {
	row := q.db.QueryRow(ctx, updateContent,
		arg.ContentID,
		arg.Title,
		arg.ContentDescription,
		arg.CategoryID,
		arg.CommentsEnabled,
		arg.ViewCountEnabled,
		arg.LikeCountEnabled,
		arg.DislikeCountEnabled,
	)
	var i Content
	err := row.Scan(
		&i.ContentID,
		&i.UserID,
		&i.CategoryID,
		&i.Title,
		&i.ContentDescription,
		&i.CommentsEnabled,
		&i.ViewCountEnabled,
		&i.LikeCountEnabled,
		&i.DislikeCountEnabled,
		&i.Status,
		&i.ViewCount,
		&i.LikeCount,
		&i.DislikeCount,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.IsDeleted,
	)
	return i, err
}

const updateContentLikeDislikeCount = `-- name: UpdateContentLikeDislikeCount :one
UPDATE content c
SET
  like_count = (
    SELECT count(*) 
    FROM content_reaction 
    WHERE content_id = c.content_id AND reaction = 'like'
  ),
  dislike_count = (
    SELECT count(*) 
    FROM content_reaction 
    WHERE content_id = c.content_id AND reaction = 'dislike'
  ),
  updated_at = now()
WHERE c.content_id = $1  -- You can use the content_id returned from the previous action here
RETURNING content_id, user_id, category_id, title, content_description, comments_enabled, view_count_enabled, like_count_enabled, dislike_count_enabled, status, view_count, like_count, dislike_count, comment_count, created_at, updated_at, published_at, is_deleted
`

func (q *Queries) UpdateContentLikeDislikeCount(ctx context.Context, contentID pgtype.UUID) (Content, error) {
	row := q.db.QueryRow(ctx, updateContentLikeDislikeCount, contentID)
	var i Content
	err := row.Scan(
		&i.ContentID,
		&i.UserID,
		&i.CategoryID,
		&i.Title,
		&i.ContentDescription,
		&i.CommentsEnabled,
		&i.ViewCountEnabled,
		&i.LikeCountEnabled,
		&i.DislikeCountEnabled,
		&i.Status,
		&i.ViewCount,
		&i.LikeCount,
		&i.DislikeCount,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.IsDeleted,
	)
	return i, err
}
