// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: content.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createContent = `-- name: CreateContent :one
INSERT INTO content (
    user_id,
    category_id,
    title,
    content_description,
    comments_enabled,
    view_count_enabled,
    like_count_enabled,
    dislike_count_enabled
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING content_id, user_id, category_id, title, content_description, comments_enabled, view_count_enabled, like_count_enabled, dislike_count_enabled, status, view_count, like_count, dislike_count, comment_count, created_at, updated_at, published_at, is_deleted
`

type CreateContentParams struct {
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
}

func (q *Queries) CreateContent(ctx context.Context, arg CreateContentParams) (Content, error) {
	row := q.db.QueryRow(ctx, createContent,
		arg.UserID,
		arg.CategoryID,
		arg.Title,
		arg.ContentDescription,
		arg.CommentsEnabled,
		arg.ViewCountEnabled,
		arg.LikeCountEnabled,
		arg.DislikeCountEnabled,
	)
	var i Content
	err := row.Scan(
		&i.ContentID,
		&i.UserID,
		&i.CategoryID,
		&i.Title,
		&i.ContentDescription,
		&i.CommentsEnabled,
		&i.ViewCountEnabled,
		&i.LikeCountEnabled,
		&i.DislikeCountEnabled,
		&i.Status,
		&i.ViewCount,
		&i.LikeCount,
		&i.DislikeCount,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.IsDeleted,
	)
	return i, err
}

const deleteContentReaction = `-- name: DeleteContentReaction :one
DELETE FROM content_reaction
WHERE content_id = $1 AND user_id = $2
RETURNING content_id
`

type DeleteContentReactionParams struct {
	ContentID pgtype.UUID
	UserID    pgtype.UUID
}

func (q *Queries) DeleteContentReaction(ctx context.Context, arg DeleteContentReactionParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, deleteContentReaction, arg.ContentID, arg.UserID)
	var content_id pgtype.UUID
	err := row.Scan(&content_id)
	return content_id, err
}

const fetchContentReactions = `-- name: FetchContentReactions :many
SELECT
  cr.content_id, cr.user_id, cr.reaction,
  u.username
FROM content_reaction cr
JOIN "user" u ON cr.user_id = u.user_id
WHERE cr.content_id = $1
LIMIT $2
`

type FetchContentReactionsParams struct {
	ContentID pgtype.UUID
	Limit     int32
}

type FetchContentReactionsRow struct {
	ContentID pgtype.UUID
	UserID    pgtype.UUID
	Reaction  string
	Username  string
}

func (q *Queries) FetchContentReactions(ctx context.Context, arg FetchContentReactionsParams) ([]FetchContentReactionsRow, error) {
	rows, err := q.db.Query(ctx, fetchContentReactions, arg.ContentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchContentReactionsRow
	for rows.Next() {
		var i FetchContentReactionsRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.Reaction,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContentByCategoryCount = `-- name: GetContentByCategoryCount :one
SELECT count(*)
FROM content
WHERE category_id = $1
  AND status = 'published'
  AND is_deleted = false
`

func (q *Queries) GetContentByCategoryCount(ctx context.Context, categoryID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getContentByCategoryCount, categoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getContentByTagCount = `-- name: GetContentByTagCount :one
SELECT count(DISTINCT c.content_id)
FROM content c
JOIN content_tag ct ON c.content_id = ct.content_id
JOIN tag t ON ct.tag_id = t.tag_id
WHERE t.tag_name = $1
  AND c.status = 'published'
  AND c.is_deleted = false
`

func (q *Queries) GetContentByTagCount(ctx context.Context, tagName string) (int64, error) {
	row := q.db.QueryRow(ctx, getContentByTagCount, tagName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getContentDetails = `-- name: GetContentDetails :one
SELECT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  u.username,
  cat.category_name,
  (
    SELECT array_agg(t.tag_name)::text[]
    FROM content_tag ct
    JOIN tag t ON ct.tag_id = t.tag_id
    WHERE ct.content_id = c.content_id
  ) AS tags
FROM content c
JOIN "user" u ON c.user_id = u.user_id
JOIN category cat ON c.category_id = cat.category_id
WHERE c.content_id = $1
`

type GetContentDetailsRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Username            string
	CategoryName        string
	Tags                []string
}

func (q *Queries) GetContentDetails(ctx context.Context, contentID pgtype.UUID) (GetContentDetailsRow, error) {
	row := q.db.QueryRow(ctx, getContentDetails, contentID)
	var i GetContentDetailsRow
	err := row.Scan(
		&i.ContentID,
		&i.UserID,
		&i.CategoryID,
		&i.Title,
		&i.ContentDescription,
		&i.CommentsEnabled,
		&i.ViewCountEnabled,
		&i.LikeCountEnabled,
		&i.DislikeCountEnabled,
		&i.Status,
		&i.ViewCount,
		&i.LikeCount,
		&i.DislikeCount,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.IsDeleted,
		&i.Username,
		&i.CategoryName,
		&i.Tags,
	)
	return i, err
}

const getContentOverview = `-- name: GetContentOverview :one
SELECT 
  COUNT(*) FILTER (WHERE status = 'draft' AND is_deleted = false) AS draft_count,
  COUNT(*) FILTER (WHERE status = 'published' AND is_deleted = false) AS published_count,
  COUNT(*) FILTER (WHERE is_deleted = true) AS deleted_count
FROM content
`

type GetContentOverviewRow struct {
	DraftCount     int64
	PublishedCount int64
	DeletedCount   int64
}

func (q *Queries) GetContentOverview(ctx context.Context) (GetContentOverviewRow, error) {
	row := q.db.QueryRow(ctx, getContentOverview)
	var i GetContentOverviewRow
	err := row.Scan(&i.DraftCount, &i.PublishedCount, &i.DeletedCount)
	return i, err
}

const getPublishedContentCount = `-- name: GetPublishedContentCount :one
SELECT count(*)
FROM content
WHERE status = 'published'
  AND is_deleted = false
`

func (q *Queries) GetPublishedContentCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getPublishedContentCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getSearchContentCount = `-- name: GetSearchContentCount :one
SELECT count(DISTINCT c.content_id)
FROM content c
JOIN "user" u ON c.user_id = u.user_id
JOIN category cat ON c.category_id = cat.category_id
LEFT JOIN content_tag ct ON c.content_id = ct.content_id
LEFT JOIN tag t ON ct.tag_id = t.tag_id
WHERE c.status = 'published'
  AND c.is_deleted = false
  AND (
    c.title ILIKE '%' || $1::text || '%'
    OR c.content_description ILIKE '%' || $1::text || '%'
    OR t.tag_name ILIKE '%' || $1::text || '%'
  )
`

func (q *Queries) GetSearchContentCount(ctx context.Context, searchTerm string) (int64, error) {
	row := q.db.QueryRow(ctx, getSearchContentCount, searchTerm)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const hardDeleteContent = `-- name: HardDeleteContent :one
DELETE FROM content
WHERE content_id = $1
RETURNING content_id, user_id, category_id, title, content_description, comments_enabled, view_count_enabled, like_count_enabled, dislike_count_enabled, status, view_count, like_count, dislike_count, comment_count, created_at, updated_at, published_at, is_deleted
`

func (q *Queries) HardDeleteContent(ctx context.Context, contentID pgtype.UUID) (Content, error) {
	row := q.db.QueryRow(ctx, hardDeleteContent, contentID)
	var i Content
	err := row.Scan(
		&i.ContentID,
		&i.UserID,
		&i.CategoryID,
		&i.Title,
		&i.ContentDescription,
		&i.CommentsEnabled,
		&i.ViewCountEnabled,
		&i.LikeCountEnabled,
		&i.DislikeCountEnabled,
		&i.Status,
		&i.ViewCount,
		&i.LikeCount,
		&i.DislikeCount,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.IsDeleted,
	)
	return i, err
}

const incrementViewCount = `-- name: IncrementViewCount :one
UPDATE content
SET
  view_count = view_count + 1
WHERE content_id = $1
RETURNING view_count
`

func (q *Queries) IncrementViewCount(ctx context.Context, contentID pgtype.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, incrementViewCount, contentID)
	var view_count int32
	err := row.Scan(&view_count)
	return view_count, err
}

const insertOrUpdateContentReaction = `-- name: InsertOrUpdateContentReaction :one
INSERT INTO content_reaction (content_id, user_id, reaction)
VALUES ($1, $2, $3)
ON CONFLICT (content_id, user_id)
DO UPDATE SET reaction = EXCLUDED.reaction
RETURNING content_id
`

type InsertOrUpdateContentReactionParams struct {
	ContentID pgtype.UUID
	UserID    pgtype.UUID
	Reaction  string
}

func (q *Queries) InsertOrUpdateContentReaction(ctx context.Context, arg InsertOrUpdateContentReactionParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertOrUpdateContentReaction, arg.ContentID, arg.UserID, arg.Reaction)
	var content_id pgtype.UUID
	err := row.Scan(&content_id)
	return content_id, err
}

const listContentByCategory = `-- name: ListContentByCategory :many
SELECT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  u.username
FROM content c
JOIN "user" u ON c.user_id = u.user_id
WHERE c.category_id = $1
  AND c.status = 'published'
  AND c.is_deleted = false
ORDER BY c.published_at DESC
LIMIT $2 OFFSET $3
`

type ListContentByCategoryParams struct {
	CategoryID pgtype.UUID
	Limit      int32
	Offset     int32
}

type ListContentByCategoryRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Username            string
}

func (q *Queries) ListContentByCategory(ctx context.Context, arg ListContentByCategoryParams) ([]ListContentByCategoryRow, error) {
	rows, err := q.db.Query(ctx, listContentByCategory, arg.CategoryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContentByCategoryRow
	for rows.Next() {
		var i ListContentByCategoryRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentByCategoryLimit = `-- name: ListContentByCategoryLimit :many
SELECT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  u.username
FROM content c
JOIN "user" u ON c.user_id = u.user_id
WHERE c.category_id = $1
  AND c.status = 'published'
  AND c.is_deleted = false
ORDER BY c.published_at DESC
LIMIT $2
`

type ListContentByCategoryLimitParams struct {
	CategoryID pgtype.UUID
	Limit      int32
}

type ListContentByCategoryLimitRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Username            string
}

func (q *Queries) ListContentByCategoryLimit(ctx context.Context, arg ListContentByCategoryLimitParams) ([]ListContentByCategoryLimitRow, error) {
	rows, err := q.db.Query(ctx, listContentByCategoryLimit, arg.CategoryID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContentByCategoryLimitRow
	for rows.Next() {
		var i ListContentByCategoryLimitRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentByTag = `-- name: ListContentByTag :many
SELECT DISTINCT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  u.username,
  cat.category_name
FROM content c
JOIN "user" u ON c.user_id = u.user_id
JOIN category cat ON c.category_id = cat.category_id
JOIN content_tag ct ON c.content_id = ct.content_id
JOIN tag t ON ct.tag_id = t.tag_id
WHERE t.tag_name = $1
  AND c.status = 'published'
  AND c.is_deleted = false
ORDER BY c.published_at DESC
LIMIT $2 OFFSET $3
`

type ListContentByTagParams struct {
	TagName string
	Limit   int32
	Offset  int32
}

type ListContentByTagRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Username            string
	CategoryName        string
}

func (q *Queries) ListContentByTag(ctx context.Context, arg ListContentByTagParams) ([]ListContentByTagRow, error) {
	rows, err := q.db.Query(ctx, listContentByTag, arg.TagName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContentByTagRow
	for rows.Next() {
		var i ListContentByTagRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Username,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentByTagLimit = `-- name: ListContentByTagLimit :many
SELECT DISTINCT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  u.username,
  cat.category_name
FROM content c
JOIN "user" u ON c.user_id = u.user_id
JOIN category cat ON c.category_id = cat.category_id
JOIN content_tag ct ON c.content_id = ct.content_id
JOIN tag t ON ct.tag_id = t.tag_id
WHERE t.tag_name = $1
  AND c.status = 'published'
  AND c.is_deleted = false
ORDER BY c.published_at DESC
LIMIT $2
`

type ListContentByTagLimitParams struct {
	TagName string
	Limit   int32
}

type ListContentByTagLimitRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Username            string
	CategoryName        string
}

func (q *Queries) ListContentByTagLimit(ctx context.Context, arg ListContentByTagLimitParams) ([]ListContentByTagLimitRow, error) {
	rows, err := q.db.Query(ctx, listContentByTagLimit, arg.TagName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContentByTagLimitRow
	for rows.Next() {
		var i ListContentByTagLimitRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Username,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeletedContent = `-- name: ListDeletedContent :many
SELECT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  u.username,
  cat.category_name
FROM content c
JOIN "user" u ON c.user_id = u.user_id
JOIN category cat ON c.category_id = cat.category_id
WHERE c.is_deleted = true
ORDER BY c.published_at DESC
LIMIT $1
`

type ListDeletedContentRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Username            string
	CategoryName        string
}

func (q *Queries) ListDeletedContent(ctx context.Context, limit int32) ([]ListDeletedContentRow, error) {
	rows, err := q.db.Query(ctx, listDeletedContent, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDeletedContentRow
	for rows.Next() {
		var i ListDeletedContentRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Username,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeletedContentOldest = `-- name: ListDeletedContentOldest :many
SELECT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  u.username,
  cat.category_name
FROM content c
JOIN "user" u ON c.user_id = u.user_id
JOIN category cat ON c.category_id = cat.category_id
WHERE c.is_deleted = true
ORDER BY c.published_at ASC
LIMIT $1
`

type ListDeletedContentOldestRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Username            string
	CategoryName        string
}

func (q *Queries) ListDeletedContentOldest(ctx context.Context, limit int32) ([]ListDeletedContentOldestRow, error) {
	rows, err := q.db.Query(ctx, listDeletedContentOldest, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDeletedContentOldestRow
	for rows.Next() {
		var i ListDeletedContentOldestRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Username,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeletedContentTitle = `-- name: ListDeletedContentTitle :many
SELECT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  u.username,
  cat.category_name
FROM content c
JOIN "user" u ON c.user_id = u.user_id
JOIN category cat ON c.category_id = cat.category_id
WHERE c.is_deleted = true
ORDER BY c.title ASC
LIMIT $1
`

type ListDeletedContentTitleRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Username            string
	CategoryName        string
}

func (q *Queries) ListDeletedContentTitle(ctx context.Context, limit int32) ([]ListDeletedContentTitleRow, error) {
	rows, err := q.db.Query(ctx, listDeletedContentTitle, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDeletedContentTitleRow
	for rows.Next() {
		var i ListDeletedContentTitleRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Username,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDraftContent = `-- name: ListDraftContent :many
SELECT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  u.username,
  cat.category_name
FROM content c
JOIN "user" u ON c.user_id = u.user_id
JOIN category cat ON c.category_id = cat.category_id
WHERE c.status = 'draft'
  AND c.is_deleted = false
ORDER BY c.published_at DESC
LIMIT $1
`

type ListDraftContentRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Username            string
	CategoryName        string
}

func (q *Queries) ListDraftContent(ctx context.Context, limit int32) ([]ListDraftContentRow, error) {
	rows, err := q.db.Query(ctx, listDraftContent, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDraftContentRow
	for rows.Next() {
		var i ListDraftContentRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Username,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDraftContentOldest = `-- name: ListDraftContentOldest :many
SELECT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  u.username,
  cat.category_name
FROM content c
JOIN "user" u ON c.user_id = u.user_id
JOIN category cat ON c.category_id = cat.category_id
WHERE c.status = 'draft'
  AND c.is_deleted = false
ORDER BY c.published_at ASC
LIMIT $1
`

type ListDraftContentOldestRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Username            string
	CategoryName        string
}

func (q *Queries) ListDraftContentOldest(ctx context.Context, limit int32) ([]ListDraftContentOldestRow, error) {
	rows, err := q.db.Query(ctx, listDraftContentOldest, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDraftContentOldestRow
	for rows.Next() {
		var i ListDraftContentOldestRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Username,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDraftContentTitle = `-- name: ListDraftContentTitle :many
SELECT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  u.username,
  cat.category_name
FROM content c
JOIN "user" u ON c.user_id = u.user_id
JOIN category cat ON c.category_id = cat.category_id
WHERE c.status = 'draft'
  AND c.is_deleted = false
ORDER BY c.title ASC
LIMIT $1
`

type ListDraftContentTitleRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Username            string
	CategoryName        string
}

func (q *Queries) ListDraftContentTitle(ctx context.Context, limit int32) ([]ListDraftContentTitleRow, error) {
	rows, err := q.db.Query(ctx, listDraftContentTitle, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDraftContentTitleRow
	for rows.Next() {
		var i ListDraftContentTitleRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Username,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedContent = `-- name: ListPublishedContent :many
SELECT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  u.username,
  cat.category_name
FROM content c
JOIN "user" u ON c.user_id = u.user_id
JOIN category cat ON c.category_id = cat.category_id
WHERE c.status = 'published'
  AND c.is_deleted = false
ORDER BY c.published_at DESC
LIMIT $1 OFFSET $2
`

type ListPublishedContentParams struct {
	Limit  int32
	Offset int32
}

type ListPublishedContentRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Username            string
	CategoryName        string
}

func (q *Queries) ListPublishedContent(ctx context.Context, arg ListPublishedContentParams) ([]ListPublishedContentRow, error) {
	rows, err := q.db.Query(ctx, listPublishedContent, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPublishedContentRow
	for rows.Next() {
		var i ListPublishedContentRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Username,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedContentLimit = `-- name: ListPublishedContentLimit :many
SELECT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  u.username,
  cat.category_name
FROM content c
JOIN "user" u ON c.user_id = u.user_id
JOIN category cat ON c.category_id = cat.category_id
WHERE c.status = 'published'
  AND c.is_deleted = false
ORDER BY c.published_at DESC
LIMIT $1
`

type ListPublishedContentLimitRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Username            string
	CategoryName        string
}

func (q *Queries) ListPublishedContentLimit(ctx context.Context, limit int32) ([]ListPublishedContentLimitRow, error) {
	rows, err := q.db.Query(ctx, listPublishedContentLimit, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPublishedContentLimitRow
	for rows.Next() {
		var i ListPublishedContentLimitRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Username,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedContentLimitOldest = `-- name: ListPublishedContentLimitOldest :many
SELECT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  u.username,
  cat.category_name
FROM content c
JOIN "user" u ON c.user_id = u.user_id
JOIN category cat ON c.category_id = cat.category_id
WHERE c.status = 'published'
  AND c.is_deleted = false
ORDER BY c.published_at ASC
LIMIT $1
`

type ListPublishedContentLimitOldestRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Username            string
	CategoryName        string
}

func (q *Queries) ListPublishedContentLimitOldest(ctx context.Context, limit int32) ([]ListPublishedContentLimitOldestRow, error) {
	rows, err := q.db.Query(ctx, listPublishedContentLimitOldest, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPublishedContentLimitOldestRow
	for rows.Next() {
		var i ListPublishedContentLimitOldestRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Username,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedContentLimitTitle = `-- name: ListPublishedContentLimitTitle :many
SELECT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  u.username,
  cat.category_name
FROM content c
JOIN "user" u ON c.user_id = u.user_id
JOIN category cat ON c.category_id = cat.category_id
WHERE c.status = 'published'
  AND c.is_deleted = false
ORDER BY c.title ASC
LIMIT $1
`

type ListPublishedContentLimitTitleRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Username            string
	CategoryName        string
}

func (q *Queries) ListPublishedContentLimitTitle(ctx context.Context, limit int32) ([]ListPublishedContentLimitTitleRow, error) {
	rows, err := q.db.Query(ctx, listPublishedContentLimitTitle, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPublishedContentLimitTitleRow
	for rows.Next() {
		var i ListPublishedContentLimitTitleRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Username,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRelatedContent = `-- name: ListRelatedContent :many
SELECT c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted
FROM content c
WHERE c.content_id <> $1
  AND c.status = 'published'
  AND c.is_deleted = false
  AND c.category_id = (SELECT category_id FROM content WHERE content_id = $1)
  AND EXISTS (
      SELECT 1
      FROM content_tag ct
      WHERE ct.content_id = c.content_id
        AND ct.tag_id IN (
            SELECT tag_id
            FROM content_tag
            WHERE content_id = $1
        )
  )
ORDER BY c.published_at DESC
LIMIT $2
`

type ListRelatedContentParams struct {
	ContentID pgtype.UUID
	Limit     int32
}

func (q *Queries) ListRelatedContent(ctx context.Context, arg ListRelatedContentParams) ([]Content, error) {
	rows, err := q.db.Query(ctx, listRelatedContent, arg.ContentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Content
	for rows.Next() {
		var i Content
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTrendingContent = `-- name: ListTrendingContent :many
SELECT 
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  (c.view_count + c.like_count + c.comment_count) AS total_interactions
FROM content c
WHERE c.status = 'published'
  AND c.is_deleted = false
  AND c.published_at >= $1
ORDER BY total_interactions DESC
LIMIT $2
`

type ListTrendingContentParams struct {
	PublishedAt pgtype.Timestamptz
	Limit       int32
}

type ListTrendingContentRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	TotalInteractions   int32
}

func (q *Queries) ListTrendingContent(ctx context.Context, arg ListTrendingContentParams) ([]ListTrendingContentRow, error) {
	rows, err := q.db.Query(ctx, listTrendingContent, arg.PublishedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTrendingContentRow
	for rows.Next() {
		var i ListTrendingContentRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.TotalInteractions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publishContent = `-- name: PublishContent :one
UPDATE content
SET
    status = 'published',
    published_at = now(),
    updated_at = now()
WHERE content_id = $1
RETURNING content_id, user_id, category_id, title, content_description, comments_enabled, view_count_enabled, like_count_enabled, dislike_count_enabled, status, view_count, like_count, dislike_count, comment_count, created_at, updated_at, published_at, is_deleted
`

func (q *Queries) PublishContent(ctx context.Context, contentID pgtype.UUID) (Content, error) {
	row := q.db.QueryRow(ctx, publishContent, contentID)
	var i Content
	err := row.Scan(
		&i.ContentID,
		&i.UserID,
		&i.CategoryID,
		&i.Title,
		&i.ContentDescription,
		&i.CommentsEnabled,
		&i.ViewCountEnabled,
		&i.LikeCountEnabled,
		&i.DislikeCountEnabled,
		&i.Status,
		&i.ViewCount,
		&i.LikeCount,
		&i.DislikeCount,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.IsDeleted,
	)
	return i, err
}

const searchContent = `-- name: SearchContent :many
SELECT DISTINCT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  u.username,
  cat.category_name
FROM content c
JOIN "user" u ON c.user_id = u.user_id
JOIN category cat ON c.category_id = cat.category_id
LEFT JOIN content_tag ct ON c.content_id = ct.content_id
LEFT JOIN tag t ON ct.tag_id = t.tag_id
WHERE c.status = 'published'
  AND c.is_deleted = false
  AND (
    c.title ILIKE '%' || $2::text || '%'
    OR c.content_description ILIKE '%' || $2::text || '%'
    OR t.tag_name ILIKE '%' || $2::text || '%'
  )
ORDER BY c.published_at DESC
LIMIT $1
`

type SearchContentParams struct {
	Limit      int32
	SearchTerm string
}

type SearchContentRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Username            string
	CategoryName        string
}

func (q *Queries) SearchContent(ctx context.Context, arg SearchContentParams) ([]SearchContentRow, error) {
	rows, err := q.db.Query(ctx, searchContent, arg.Limit, arg.SearchTerm)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchContentRow
	for rows.Next() {
		var i SearchContentRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Username,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDelContent = `-- name: SearchDelContent :many
SELECT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  u.username,
  cat.category_name
FROM content c
JOIN "user" u ON c.user_id = u.user_id
JOIN category cat ON c.category_id = cat.category_id
WHERE c.is_deleted = true
  AND (
    c.title ILIKE '%' || $2::text || '%'
    OR c.content_description ILIKE '%' || $2::text || '%'
  )
ORDER BY c.published_at DESC
LIMIT $1
`

type SearchDelContentParams struct {
	Limit      int32
	SearchTerm string
}

type SearchDelContentRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Username            string
	CategoryName        string
}

func (q *Queries) SearchDelContent(ctx context.Context, arg SearchDelContentParams) ([]SearchDelContentRow, error) {
	rows, err := q.db.Query(ctx, searchDelContent, arg.Limit, arg.SearchTerm)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchDelContentRow
	for rows.Next() {
		var i SearchDelContentRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Username,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDraftContent = `-- name: SearchDraftContent :many
SELECT
  c.content_id, c.user_id, c.category_id, c.title, c.content_description, c.comments_enabled, c.view_count_enabled, c.like_count_enabled, c.dislike_count_enabled, c.status, c.view_count, c.like_count, c.dislike_count, c.comment_count, c.created_at, c.updated_at, c.published_at, c.is_deleted,
  u.username,
  cat.category_name
FROM content c
JOIN "user" u ON c.user_id = u.user_id
JOIN category cat ON c.category_id = cat.category_id
WHERE c.status = 'draft'
  AND c.is_deleted = false
  AND (
    c.title ILIKE '%' || $2::text || '%'
    OR c.content_description ILIKE '%' || $2::text || '%'
  )
ORDER BY c.published_at DESC
LIMIT $1
`

type SearchDraftContentParams struct {
	Limit      int32
	SearchTerm string
}

type SearchDraftContentRow struct {
	ContentID           pgtype.UUID
	UserID              pgtype.UUID
	CategoryID          pgtype.UUID
	Title               string
	ContentDescription  string
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
	Status              string
	ViewCount           int32
	LikeCount           int32
	DislikeCount        int32
	CommentCount        int32
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	PublishedAt         pgtype.Timestamptz
	IsDeleted           pgtype.Bool
	Username            string
	CategoryName        string
}

func (q *Queries) SearchDraftContent(ctx context.Context, arg SearchDraftContentParams) ([]SearchDraftContentRow, error) {
	rows, err := q.db.Query(ctx, searchDraftContent, arg.Limit, arg.SearchTerm)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchDraftContentRow
	for rows.Next() {
		var i SearchDraftContentRow
		if err := rows.Scan(
			&i.ContentID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.ContentDescription,
			&i.CommentsEnabled,
			&i.ViewCountEnabled,
			&i.LikeCountEnabled,
			&i.DislikeCountEnabled,
			&i.Status,
			&i.ViewCount,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.IsDeleted,
			&i.Username,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteContent = `-- name: SoftDeleteContent :one
UPDATE content
SET
    is_deleted = true,
    updated_at = now()
WHERE content_id = $1
RETURNING content_id, user_id, category_id, title, content_description, comments_enabled, view_count_enabled, like_count_enabled, dislike_count_enabled, status, view_count, like_count, dislike_count, comment_count, created_at, updated_at, published_at, is_deleted
`

func (q *Queries) SoftDeleteContent(ctx context.Context, contentID pgtype.UUID) (Content, error) {
	row := q.db.QueryRow(ctx, softDeleteContent, contentID)
	var i Content
	err := row.Scan(
		&i.ContentID,
		&i.UserID,
		&i.CategoryID,
		&i.Title,
		&i.ContentDescription,
		&i.CommentsEnabled,
		&i.ViewCountEnabled,
		&i.LikeCountEnabled,
		&i.DislikeCountEnabled,
		&i.Status,
		&i.ViewCount,
		&i.LikeCount,
		&i.DislikeCount,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.IsDeleted,
	)
	return i, err
}

const updateContent = `-- name: UpdateContent :one
UPDATE content
SET
    title = COALESCE($2, title),
    content_description = COALESCE($3, content_description),
    category_id = COALESCE($4, category_id),
    comments_enabled = COALESCE($5, comments_enabled),
    view_count_enabled = COALESCE($6, view_count_enabled),
    like_count_enabled = COALESCE($7, like_count_enabled),
    dislike_count_enabled = COALESCE($8, dislike_count_enabled),
    updated_at = now()
WHERE content_id = $1
RETURNING content_id, user_id, category_id, title, content_description, comments_enabled, view_count_enabled, like_count_enabled, dislike_count_enabled, status, view_count, like_count, dislike_count, comment_count, created_at, updated_at, published_at, is_deleted
`

type UpdateContentParams struct {
	ContentID           pgtype.UUID
	Title               string
	ContentDescription  string
	CategoryID          pgtype.UUID
	CommentsEnabled     bool
	ViewCountEnabled    bool
	LikeCountEnabled    bool
	DislikeCountEnabled bool
}

func (q *Queries) UpdateContent(ctx context.Context, arg UpdateContentParams) (Content, error) {
	row := q.db.QueryRow(ctx, updateContent,
		arg.ContentID,
		arg.Title,
		arg.ContentDescription,
		arg.CategoryID,
		arg.CommentsEnabled,
		arg.ViewCountEnabled,
		arg.LikeCountEnabled,
		arg.DislikeCountEnabled,
	)
	var i Content
	err := row.Scan(
		&i.ContentID,
		&i.UserID,
		&i.CategoryID,
		&i.Title,
		&i.ContentDescription,
		&i.CommentsEnabled,
		&i.ViewCountEnabled,
		&i.LikeCountEnabled,
		&i.DislikeCountEnabled,
		&i.Status,
		&i.ViewCount,
		&i.LikeCount,
		&i.DislikeCount,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.IsDeleted,
	)
	return i, err
}

const updateContentLikeDislikeCount = `-- name: UpdateContentLikeDislikeCount :one
UPDATE content c
SET
  like_count = (
    SELECT count(*) 
    FROM content_reaction 
    WHERE content_id = c.content_id AND reaction = 'like'
  ),
  dislike_count = (
    SELECT count(*) 
    FROM content_reaction 
    WHERE content_id = c.content_id AND reaction = 'dislike'
  ),
  updated_at = now()
WHERE c.content_id = $1 
RETURNING content_id, user_id, category_id, title, content_description, comments_enabled, view_count_enabled, like_count_enabled, dislike_count_enabled, status, view_count, like_count, dislike_count, comment_count, created_at, updated_at, published_at, is_deleted
`

func (q *Queries) UpdateContentLikeDislikeCount(ctx context.Context, contentID pgtype.UUID) (Content, error) {
	row := q.db.QueryRow(ctx, updateContentLikeDislikeCount, contentID)
	var i Content
	err := row.Scan(
		&i.ContentID,
		&i.UserID,
		&i.CategoryID,
		&i.Title,
		&i.ContentDescription,
		&i.CommentsEnabled,
		&i.ViewCountEnabled,
		&i.LikeCountEnabled,
		&i.DislikeCountEnabled,
		&i.Status,
		&i.ViewCount,
		&i.LikeCount,
		&i.DislikeCount,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.IsDeleted,
	)
	return i, err
}
