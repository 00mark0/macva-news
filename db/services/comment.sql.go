// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: comment.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createComment = `-- name: CreateComment :one
INSERT INTO comment (content_id, user_id, comment_text)
VALUES ($1, $2, $3)
RETURNING comment_id, content_id, user_id, comment_text, score, created_at, updated_at, is_deleted, parent_comment_id
`

type CreateCommentParams struct {
	ContentID   pgtype.UUID
	UserID      pgtype.UUID
	CommentText string
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, createComment, arg.ContentID, arg.UserID, arg.CommentText)
	var i Comment
	err := row.Scan(
		&i.CommentID,
		&i.ContentID,
		&i.UserID,
		&i.CommentText,
		&i.Score,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsDeleted,
		&i.ParentCommentID,
	)
	return i, err
}

const createReply = `-- name: CreateReply :one
INSERT INTO comment (content_id, user_id, comment_text, parent_comment_id)
VALUES ($1, $2, $3, $4)
RETURNING comment_id, content_id, user_id, comment_text, score, created_at, updated_at, is_deleted, parent_comment_id
`

type CreateReplyParams struct {
	ContentID       pgtype.UUID
	UserID          pgtype.UUID
	CommentText     string
	ParentCommentID pgtype.UUID
}

func (q *Queries) CreateReply(ctx context.Context, arg CreateReplyParams) (Comment, error) {
	row := q.db.QueryRow(ctx, createReply,
		arg.ContentID,
		arg.UserID,
		arg.CommentText,
		arg.ParentCommentID,
	)
	var i Comment
	err := row.Scan(
		&i.CommentID,
		&i.ContentID,
		&i.UserID,
		&i.CommentText,
		&i.Score,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsDeleted,
		&i.ParentCommentID,
	)
	return i, err
}

const deleteCommentReaction = `-- name: DeleteCommentReaction :one
DELETE FROM comment_reaction
WHERE comment_id = $1 AND user_id = $2
RETURNING comment_id
`

type DeleteCommentReactionParams struct {
	CommentID pgtype.UUID
	UserID    pgtype.UUID
}

func (q *Queries) DeleteCommentReaction(ctx context.Context, arg DeleteCommentReactionParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, deleteCommentReaction, arg.CommentID, arg.UserID)
	var comment_id pgtype.UUID
	err := row.Scan(&comment_id)
	return comment_id, err
}

const fetchCommentReactions = `-- name: FetchCommentReactions :many
SELECT
  cr.comment_id, cr.user_id, cr.reaction,
  u.username
FROM comment_reaction cr
JOIN "user" u ON cr.user_id = u.user_id
WHERE cr.comment_id = $1
LIMIT $2
`

type FetchCommentReactionsParams struct {
	CommentID pgtype.UUID
	Limit     int32
}

type FetchCommentReactionsRow struct {
	CommentID pgtype.UUID
	UserID    pgtype.UUID
	Reaction  string
	Username  string
}

func (q *Queries) FetchCommentReactions(ctx context.Context, arg FetchCommentReactionsParams) ([]FetchCommentReactionsRow, error) {
	rows, err := q.db.Query(ctx, fetchCommentReactions, arg.CommentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchCommentReactionsRow
	for rows.Next() {
		var i FetchCommentReactionsRow
		if err := rows.Scan(
			&i.CommentID,
			&i.UserID,
			&i.Reaction,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentByID = `-- name: GetCommentByID :one
SELECT comment_id, content_id, user_id, comment_text, score, created_at, updated_at, is_deleted, parent_comment_id FROM comment
WHERE comment_id = $1
`

func (q *Queries) GetCommentByID(ctx context.Context, commentID pgtype.UUID) (Comment, error) {
	row := q.db.QueryRow(ctx, getCommentByID, commentID)
	var i Comment
	err := row.Scan(
		&i.CommentID,
		&i.ContentID,
		&i.UserID,
		&i.CommentText,
		&i.Score,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsDeleted,
		&i.ParentCommentID,
	)
	return i, err
}

const getCommentCountForContent = `-- name: GetCommentCountForContent :one
SELECT count(*) FROM comment
WHERE content_id = $1
  AND is_deleted = false
`

func (q *Queries) GetCommentCountForContent(ctx context.Context, contentID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getCommentCountForContent, contentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getReplyCount = `-- name: GetReplyCount :one
SELECT COUNT(*) 
FROM comment
WHERE parent_comment_id = $1 AND is_deleted = false
`

func (q *Queries) GetReplyCount(ctx context.Context, parentCommentID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getReplyCount, parentCommentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserCommentReaction = `-- name: GetUserCommentReaction :one
SELECT comment_id, user_id, reaction FROM comment_reaction
WHERE comment_id = $1 AND user_id = $2
`

type GetUserCommentReactionParams struct {
	CommentID pgtype.UUID
	UserID    pgtype.UUID
}

func (q *Queries) GetUserCommentReaction(ctx context.Context, arg GetUserCommentReactionParams) (CommentReaction, error) {
	row := q.db.QueryRow(ctx, getUserCommentReaction, arg.CommentID, arg.UserID)
	var i CommentReaction
	err := row.Scan(&i.CommentID, &i.UserID, &i.Reaction)
	return i, err
}

const getUserReactionsForContentComments = `-- name: GetUserReactionsForContentComments :many
SELECT
  cr.comment_id, cr.user_id, cr.reaction,
  u.username
FROM comment_reaction cr
JOIN comment c ON cr.comment_id = c.comment_id
JOIN "user" u ON cr.user_id = u.user_id
WHERE c.content_id = $1
  AND cr.user_id = $2
  AND c.is_deleted = false
`

type GetUserReactionsForContentCommentsParams struct {
	ContentID pgtype.UUID
	UserID    pgtype.UUID
}

type GetUserReactionsForContentCommentsRow struct {
	CommentID pgtype.UUID
	UserID    pgtype.UUID
	Reaction  string
	Username  string
}

func (q *Queries) GetUserReactionsForContentComments(ctx context.Context, arg GetUserReactionsForContentCommentsParams) ([]GetUserReactionsForContentCommentsRow, error) {
	rows, err := q.db.Query(ctx, getUserReactionsForContentComments, arg.ContentID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserReactionsForContentCommentsRow
	for rows.Next() {
		var i GetUserReactionsForContentCommentsRow
		if err := rows.Scan(
			&i.CommentID,
			&i.UserID,
			&i.Reaction,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertOrUpdateCommentReaction = `-- name: InsertOrUpdateCommentReaction :one
INSERT INTO comment_reaction (comment_id, user_id, reaction)
VALUES ($1, $2, $3)
ON CONFLICT (comment_id, user_id)
DO UPDATE SET reaction = EXCLUDED.reaction
RETURNING comment_id
`

type InsertOrUpdateCommentReactionParams struct {
	CommentID pgtype.UUID
	UserID    pgtype.UUID
	Reaction  string
}

func (q *Queries) InsertOrUpdateCommentReaction(ctx context.Context, arg InsertOrUpdateCommentReactionParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertOrUpdateCommentReaction, arg.CommentID, arg.UserID, arg.Reaction)
	var comment_id pgtype.UUID
	err := row.Scan(&comment_id)
	return comment_id, err
}

const listCommentReplies = `-- name: ListCommentReplies :many
SELECT cm.comment_id, cm.content_id, cm.user_id, cm.comment_text, cm.score, cm.created_at, cm.updated_at, cm.is_deleted, cm.parent_comment_id, u.username, u.pfp, u.role 
FROM comment cm 
JOIN "user" u ON cm.user_id = u.user_id
WHERE cm.parent_comment_id = $1 AND cm.is_deleted = false
ORDER BY cm.created_at ASC
LIMIT $2
`

type ListCommentRepliesParams struct {
	ParentCommentID pgtype.UUID
	Limit           int32
}

type ListCommentRepliesRow struct {
	CommentID       pgtype.UUID
	ContentID       pgtype.UUID
	UserID          pgtype.UUID
	CommentText     string
	Score           int32
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	IsDeleted       pgtype.Bool
	ParentCommentID pgtype.UUID
	Username        string
	Pfp             string
	Role            string
}

func (q *Queries) ListCommentReplies(ctx context.Context, arg ListCommentRepliesParams) ([]ListCommentRepliesRow, error) {
	rows, err := q.db.Query(ctx, listCommentReplies, arg.ParentCommentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCommentRepliesRow
	for rows.Next() {
		var i ListCommentRepliesRow
		if err := rows.Scan(
			&i.CommentID,
			&i.ContentID,
			&i.UserID,
			&i.CommentText,
			&i.Score,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsDeleted,
			&i.ParentCommentID,
			&i.Username,
			&i.Pfp,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentComments = `-- name: ListContentComments :many
SELECT
  cm.comment_id, cm.content_id, cm.user_id, cm.comment_text, cm.score, cm.created_at, cm.updated_at, cm.is_deleted, cm.parent_comment_id,
  u.username,
  u.pfp,
  u.role
FROM comment cm
JOIN "user" u ON cm.user_id = u.user_id
WHERE cm.content_id = $1
  AND cm.is_deleted = false
  AND cm.parent_comment_id IS NULL
ORDER BY cm.created_at DESC
LIMIT $2
`

type ListContentCommentsParams struct {
	ContentID pgtype.UUID
	Limit     int32
}

type ListContentCommentsRow struct {
	CommentID       pgtype.UUID
	ContentID       pgtype.UUID
	UserID          pgtype.UUID
	CommentText     string
	Score           int32
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	IsDeleted       pgtype.Bool
	ParentCommentID pgtype.UUID
	Username        string
	Pfp             string
	Role            string
}

func (q *Queries) ListContentComments(ctx context.Context, arg ListContentCommentsParams) ([]ListContentCommentsRow, error) {
	rows, err := q.db.Query(ctx, listContentComments, arg.ContentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContentCommentsRow
	for rows.Next() {
		var i ListContentCommentsRow
		if err := rows.Scan(
			&i.CommentID,
			&i.ContentID,
			&i.UserID,
			&i.CommentText,
			&i.Score,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsDeleted,
			&i.ParentCommentID,
			&i.Username,
			&i.Pfp,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentCommentsByScore = `-- name: ListContentCommentsByScore :many
SELECT
  cm.comment_id, cm.content_id, cm.user_id, cm.comment_text, cm.score, cm.created_at, cm.updated_at, cm.is_deleted, cm.parent_comment_id,
  u.username,
  u.pfp,
  u.role
FROM comment cm
JOIN "user" u ON cm.user_id = u.user_id
WHERE cm.content_id = $1
  AND cm.is_deleted = false
  AND cm.parent_comment_id IS NULL
ORDER BY cm.score DESC
LIMIT $2
`

type ListContentCommentsByScoreParams struct {
	ContentID pgtype.UUID
	Limit     int32
}

type ListContentCommentsByScoreRow struct {
	CommentID       pgtype.UUID
	ContentID       pgtype.UUID
	UserID          pgtype.UUID
	CommentText     string
	Score           int32
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	IsDeleted       pgtype.Bool
	ParentCommentID pgtype.UUID
	Username        string
	Pfp             string
	Role            string
}

func (q *Queries) ListContentCommentsByScore(ctx context.Context, arg ListContentCommentsByScoreParams) ([]ListContentCommentsByScoreRow, error) {
	rows, err := q.db.Query(ctx, listContentCommentsByScore, arg.ContentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContentCommentsByScoreRow
	for rows.Next() {
		var i ListContentCommentsByScoreRow
		if err := rows.Scan(
			&i.CommentID,
			&i.ContentID,
			&i.UserID,
			&i.CommentText,
			&i.Score,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsDeleted,
			&i.ParentCommentID,
			&i.Username,
			&i.Pfp,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteComment = `-- name: SoftDeleteComment :one
UPDATE comment
SET 
  is_deleted = true,
  updated_at = now()
WHERE 
  comment_id = $1
  AND is_deleted = false
RETURNING
  comment_id,
  is_deleted,
  updated_at
`

type SoftDeleteCommentRow struct {
	CommentID pgtype.UUID
	IsDeleted pgtype.Bool
	UpdatedAt pgtype.Timestamptz
}

func (q *Queries) SoftDeleteComment(ctx context.Context, commentID pgtype.UUID) (SoftDeleteCommentRow, error) {
	row := q.db.QueryRow(ctx, softDeleteComment, commentID)
	var i SoftDeleteCommentRow
	err := row.Scan(&i.CommentID, &i.IsDeleted, &i.UpdatedAt)
	return i, err
}

const updateComment = `-- name: UpdateComment :one
UPDATE comment
SET 
  comment_text = $1,
  updated_at = now()
WHERE 
  comment_id = $2
  AND is_deleted = false
RETURNING
  comment_id,
  comment_text,
  updated_at
`

type UpdateCommentParams struct {
	CommentText string
	CommentID   pgtype.UUID
}

type UpdateCommentRow struct {
	CommentID   pgtype.UUID
	CommentText string
	UpdatedAt   pgtype.Timestamptz
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) (UpdateCommentRow, error) {
	row := q.db.QueryRow(ctx, updateComment, arg.CommentText, arg.CommentID)
	var i UpdateCommentRow
	err := row.Scan(&i.CommentID, &i.CommentText, &i.UpdatedAt)
	return i, err
}

const updateCommentScore = `-- name: UpdateCommentScore :one
UPDATE comment c
SET
  score = (
    SELECT count(*) 
    FROM comment_reaction 
    WHERE comment_id = c.comment_id AND reaction = 'like'
  )
  -
  (
    SELECT count(*) 
    FROM comment_reaction 
    WHERE comment_id = c.comment_id AND reaction = 'dislike'
  ),
  updated_at = c.updated_at  -- Explicitly keep the current value
WHERE c.comment_id = $1
RETURNING comment_id, content_id, user_id, comment_text, score, created_at, updated_at, is_deleted, parent_comment_id
`

func (q *Queries) UpdateCommentScore(ctx context.Context, commentID pgtype.UUID) (Comment, error) {
	row := q.db.QueryRow(ctx, updateCommentScore, commentID)
	var i Comment
	err := row.Scan(
		&i.CommentID,
		&i.ContentID,
		&i.UserID,
		&i.CommentText,
		&i.Score,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsDeleted,
		&i.ParentCommentID,
	)
	return i, err
}
