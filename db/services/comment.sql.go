// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: comment.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteCommentReaction = `-- name: DeleteCommentReaction :one
DELETE FROM comment_reaction
WHERE comment_id = $1 AND user_id = $2
RETURNING comment_id
`

type DeleteCommentReactionParams struct {
	CommentID pgtype.UUID
	UserID    pgtype.UUID
}

func (q *Queries) DeleteCommentReaction(ctx context.Context, arg DeleteCommentReactionParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, deleteCommentReaction, arg.CommentID, arg.UserID)
	var comment_id pgtype.UUID
	err := row.Scan(&comment_id)
	return comment_id, err
}

const fetchCommentReactions = `-- name: FetchCommentReactions :many
SELECT
  cr.comment_id, cr.user_id, cr.reaction,
  row_to_json(u) AS user_info
FROM comment_reaction cr
JOIN "user" u ON cr.user_id = u.user_id
WHERE cr.comment_id = $1
`

type FetchCommentReactionsRow struct {
	CommentID pgtype.UUID
	UserID    pgtype.UUID
	Reaction  string
	UserInfo  []byte
}

func (q *Queries) FetchCommentReactions(ctx context.Context, commentID pgtype.UUID) ([]FetchCommentReactionsRow, error) {
	rows, err := q.db.Query(ctx, fetchCommentReactions, commentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchCommentReactionsRow
	for rows.Next() {
		var i FetchCommentReactionsRow
		if err := rows.Scan(
			&i.CommentID,
			&i.UserID,
			&i.Reaction,
			&i.UserInfo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertOrUpdateCommentReaction = `-- name: InsertOrUpdateCommentReaction :one
INSERT INTO comment_reaction (comment_id, user_id, reaction)
VALUES ($1, $2, $3)
ON CONFLICT (comment_id, user_id)
DO UPDATE SET reaction = EXCLUDED.reaction
RETURNING comment_id
`

type InsertOrUpdateCommentReactionParams struct {
	CommentID pgtype.UUID
	UserID    pgtype.UUID
	Reaction  string
}

func (q *Queries) InsertOrUpdateCommentReaction(ctx context.Context, arg InsertOrUpdateCommentReactionParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertOrUpdateCommentReaction, arg.CommentID, arg.UserID, arg.Reaction)
	var comment_id pgtype.UUID
	err := row.Scan(&comment_id)
	return comment_id, err
}

const listContentComments = `-- name: ListContentComments :many
SELECT
  cm.comment_id, cm.content_id, cm.user_id, cm.comment_text, cm.like_count, cm.dislike_count, cm.created_at, cm.updated_at, cm.is_deleted,
  row_to_json(u) AS author
FROM comment cm
JOIN "user" u ON cm.user_id = u.user_id
WHERE cm.content_id = $1
  AND cm.is_deleted = false
ORDER BY cm.created_at ASC
LIMIT $2
`

type ListContentCommentsParams struct {
	ContentID pgtype.UUID
	Limit     int32
}

type ListContentCommentsRow struct {
	CommentID    pgtype.UUID
	ContentID    pgtype.UUID
	UserID       pgtype.UUID
	CommentText  string
	LikeCount    int32
	DislikeCount int32
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	IsDeleted    pgtype.Bool
	Author       []byte
}

func (q *Queries) ListContentComments(ctx context.Context, arg ListContentCommentsParams) ([]ListContentCommentsRow, error) {
	rows, err := q.db.Query(ctx, listContentComments, arg.ContentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContentCommentsRow
	for rows.Next() {
		var i ListContentCommentsRow
		if err := rows.Scan(
			&i.CommentID,
			&i.ContentID,
			&i.UserID,
			&i.CommentText,
			&i.LikeCount,
			&i.DislikeCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsDeleted,
			&i.Author,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCommentLikeDislikeCount = `-- name: UpdateCommentLikeDislikeCount :one
UPDATE comment c
SET
  like_count = (
    SELECT count(*) 
    FROM comment_reaction 
    WHERE comment_id = c.comment_id AND reaction = 'like'
  ),
  dislike_count = (
    SELECT count(*) 
    FROM comment_reaction 
    WHERE comment_id = c.comment_id AND reaction = 'dislike'
  ),
  updated_at = now()
WHERE c.comment_id = $1
RETURNING comment_id, content_id, user_id, comment_text, like_count, dislike_count, created_at, updated_at, is_deleted
`

func (q *Queries) UpdateCommentLikeDislikeCount(ctx context.Context, commentID pgtype.UUID) (Comment, error) {
	row := q.db.QueryRow(ctx, updateCommentLikeDislikeCount, commentID)
	var i Comment
	err := row.Scan(
		&i.CommentID,
		&i.ContentID,
		&i.UserID,
		&i.CommentText,
		&i.LikeCount,
		&i.DislikeCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsDeleted,
	)
	return i, err
}
