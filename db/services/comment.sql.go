// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: comment.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createComment = `-- name: CreateComment :one
INSERT INTO comment (content_id, user_id, comment_text)
VALUES ($1, $2, $3)
RETURNING comment_id, content_id, user_id, comment_text, score, created_at, updated_at, is_deleted
`

type CreateCommentParams struct {
	ContentID   pgtype.UUID
	UserID      pgtype.UUID
	CommentText string
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, createComment, arg.ContentID, arg.UserID, arg.CommentText)
	var i Comment
	err := row.Scan(
		&i.CommentID,
		&i.ContentID,
		&i.UserID,
		&i.CommentText,
		&i.Score,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsDeleted,
	)
	return i, err
}

const deleteCommentReaction = `-- name: DeleteCommentReaction :one
DELETE FROM comment_reaction
WHERE comment_id = $1 AND user_id = $2
RETURNING comment_id
`

type DeleteCommentReactionParams struct {
	CommentID pgtype.UUID
	UserID    pgtype.UUID
}

func (q *Queries) DeleteCommentReaction(ctx context.Context, arg DeleteCommentReactionParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, deleteCommentReaction, arg.CommentID, arg.UserID)
	var comment_id pgtype.UUID
	err := row.Scan(&comment_id)
	return comment_id, err
}

const fetchCommentReactions = `-- name: FetchCommentReactions :many
SELECT
  cr.comment_id, cr.user_id, cr.reaction,
  u.username
FROM comment_reaction cr
JOIN "user" u ON cr.user_id = u.user_id
WHERE cr.comment_id = $1
LIMIT $2
`

type FetchCommentReactionsParams struct {
	CommentID pgtype.UUID
	Limit     int32
}

type FetchCommentReactionsRow struct {
	CommentID pgtype.UUID
	UserID    pgtype.UUID
	Reaction  string
	Username  string
}

func (q *Queries) FetchCommentReactions(ctx context.Context, arg FetchCommentReactionsParams) ([]FetchCommentReactionsRow, error) {
	rows, err := q.db.Query(ctx, fetchCommentReactions, arg.CommentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchCommentReactionsRow
	for rows.Next() {
		var i FetchCommentReactionsRow
		if err := rows.Scan(
			&i.CommentID,
			&i.UserID,
			&i.Reaction,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertOrUpdateCommentReaction = `-- name: InsertOrUpdateCommentReaction :one
INSERT INTO comment_reaction (comment_id, user_id, reaction)
VALUES ($1, $2, $3)
ON CONFLICT (comment_id, user_id)
DO UPDATE SET reaction = EXCLUDED.reaction
RETURNING comment_id
`

type InsertOrUpdateCommentReactionParams struct {
	CommentID pgtype.UUID
	UserID    pgtype.UUID
	Reaction  string
}

func (q *Queries) InsertOrUpdateCommentReaction(ctx context.Context, arg InsertOrUpdateCommentReactionParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertOrUpdateCommentReaction, arg.CommentID, arg.UserID, arg.Reaction)
	var comment_id pgtype.UUID
	err := row.Scan(&comment_id)
	return comment_id, err
}

const listContentComments = `-- name: ListContentComments :many
SELECT
  cm.comment_id, cm.content_id, cm.user_id, cm.comment_text, cm.score, cm.created_at, cm.updated_at, cm.is_deleted,
  u.username
FROM comment cm
JOIN "user" u ON cm.user_id = u.user_id
WHERE cm.content_id = $1
  AND cm.is_deleted = false
ORDER BY cm.created_at ASC
LIMIT $2
`

type ListContentCommentsParams struct {
	ContentID pgtype.UUID
	Limit     int32
}

type ListContentCommentsRow struct {
	CommentID   pgtype.UUID
	ContentID   pgtype.UUID
	UserID      pgtype.UUID
	CommentText string
	Score       int32
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	IsDeleted   pgtype.Bool
	Username    string
}

func (q *Queries) ListContentComments(ctx context.Context, arg ListContentCommentsParams) ([]ListContentCommentsRow, error) {
	rows, err := q.db.Query(ctx, listContentComments, arg.ContentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContentCommentsRow
	for rows.Next() {
		var i ListContentCommentsRow
		if err := rows.Scan(
			&i.CommentID,
			&i.ContentID,
			&i.UserID,
			&i.CommentText,
			&i.Score,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsDeleted,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentCommentsByScore = `-- name: ListContentCommentsByScore :many
SELECT
  cm.comment_id, cm.content_id, cm.user_id, cm.comment_text, cm.score, cm.created_at, cm.updated_at, cm.is_deleted,
  u.username
FROM comment cm
JOIN "user" u ON cm.user_id = u.user_id
WHERE cm.content_id = $1
  AND cm.is_deleted = false
ORDER BY cm.score DESC
LIMIT $2
`

type ListContentCommentsByScoreParams struct {
	ContentID pgtype.UUID
	Limit     int32
}

type ListContentCommentsByScoreRow struct {
	CommentID   pgtype.UUID
	ContentID   pgtype.UUID
	UserID      pgtype.UUID
	CommentText string
	Score       int32
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	IsDeleted   pgtype.Bool
	Username    string
}

func (q *Queries) ListContentCommentsByScore(ctx context.Context, arg ListContentCommentsByScoreParams) ([]ListContentCommentsByScoreRow, error) {
	rows, err := q.db.Query(ctx, listContentCommentsByScore, arg.ContentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContentCommentsByScoreRow
	for rows.Next() {
		var i ListContentCommentsByScoreRow
		if err := rows.Scan(
			&i.CommentID,
			&i.ContentID,
			&i.UserID,
			&i.CommentText,
			&i.Score,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsDeleted,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteComment = `-- name: SoftDeleteComment :one
UPDATE comment
SET 
  is_deleted = true,
  updated_at = now()
WHERE 
  comment_id = $1
  AND is_deleted = false
RETURNING
  comment_id,
  is_deleted,
  updated_at
`

type SoftDeleteCommentRow struct {
	CommentID pgtype.UUID
	IsDeleted pgtype.Bool
	UpdatedAt pgtype.Timestamptz
}

func (q *Queries) SoftDeleteComment(ctx context.Context, commentID pgtype.UUID) (SoftDeleteCommentRow, error) {
	row := q.db.QueryRow(ctx, softDeleteComment, commentID)
	var i SoftDeleteCommentRow
	err := row.Scan(&i.CommentID, &i.IsDeleted, &i.UpdatedAt)
	return i, err
}

const updateComment = `-- name: UpdateComment :one
UPDATE comment
SET 
  comment_text = $1,
  updated_at = now()
WHERE 
  comment_id = $2
  AND is_deleted = false
RETURNING
  comment_id,
  comment_text,
  updated_at
`

type UpdateCommentParams struct {
	CommentText string
	CommentID   pgtype.UUID
}

type UpdateCommentRow struct {
	CommentID   pgtype.UUID
	CommentText string
	UpdatedAt   pgtype.Timestamptz
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) (UpdateCommentRow, error) {
	row := q.db.QueryRow(ctx, updateComment, arg.CommentText, arg.CommentID)
	var i UpdateCommentRow
	err := row.Scan(&i.CommentID, &i.CommentText, &i.UpdatedAt)
	return i, err
}

const updateCommentScore = `-- name: UpdateCommentScore :one
UPDATE comment c
SET
  score = (
    SELECT count(*) 
    FROM comment_reaction 
    WHERE comment_id = c.comment_id AND reaction = 'like'
  )
  -
  (
    SELECT count(*) 
    FROM comment_reaction 
    WHERE comment_id = c.comment_id AND reaction = 'dislike'
  ),
  updated_at = now()
WHERE c.comment_id = $1
RETURNING comment_id, content_id, user_id, comment_text, score, created_at, updated_at, is_deleted
`

func (q *Queries) UpdateCommentScore(ctx context.Context, commentID pgtype.UUID) (Comment, error) {
	row := q.db.QueryRow(ctx, updateCommentScore, commentID)
	var i Comment
	err := row.Scan(
		&i.CommentID,
		&i.ContentID,
		&i.UserID,
		&i.CommentText,
		&i.Score,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsDeleted,
	)
	return i, err
}
